cli_disp('In this example we will consider data generated by the following system:', width);
A_true = [0 2 1;1 1 1;2 0 1]
B_true = [1 0;0 1;0 0]
fprintf('\n');

cli_press_any_key();
cli_disp('We will use this system to generate our data using the following intial state and input', width);
x0_true = [0;0;0]
U_true = [1 0 0 1;2 1 0 1]
fprintf('\n');

cli_press_any_key();
cli_disp('This will result in the following state and input data', width);
[U_true, X_true] = generateData(A_true,B_true,x0_true,U_true)
fprintf('\n');

cli_press_any_key();
cli_disp('We can use this data to see if certain properties hold.',width);
options = [{'System identification'}; 
           {'Controllability'};
           {'Stabillisability'};
           {'State feedback'};
           {'Deadbeat control'};
           {'Linear quadratic regulation'};
           {'Dynamic measurement feedback'};
           {'Show data again'};
           {'Exit example'}];

fprintf('\n');
response = cli_options(options, width);
while response ~= 8
    fprintf('\n');
    switch(response)
        % ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        case 1 % System Identification
            fprintf(cli_bf(' -- System Identification -- \n'))
            cli_disp('We can use the provided function for system identification to check if we are able to retreive the original system matrices.', width)
            
            fprintf('\n')
            cli_disp('[bool, A, B] = isInformIdentification(X,U)', width)
            cli_disp(sprintf('bool = %d\n', isInformIdentification(X_true,U_true)), width)
            
            fprintf('\n')
            cli_disp(join(['As we can see the data is not informative for system identification. ' ...
                           'Thus we are not able to retreive the original system matrices. ' ]), width)
            fprintf('\n')
            cli_disp(join(['For the data to be informative for system identification we need that the data is full rank, i.e. rank([X₋ ; U]) = 5.']), width)
            disp([X_true(:,1:end-1) ; U_true]);
            cli_disp(join(['However, in our example the data matrices have rank at most rank 4 and hence the data is not informative for system identification.'], ''), width)
            
            fprintf('\n')
            cli_disp(join(['If we where to generate 1 more data point, then the matrix [X₋ ; U] will be of size 5*5 and might be informative for system identification. ']), width)
            U = [1 0 0 1 0;2 1 0 1 0]
            X = [0 1 4 10 31 92 ; 0 2 4 10 31 92 ; 0 0 2 10 30 92]
            
            cli_disp(join(['Thus we will now see if the following data is informative for system identification.']), width)
            cli_press_any_key();
            [bool,A,B] = isInformIdentification(X,U)
            cli_disp('As we can see the extended data is of sufficient rank and is hence informative for system identification.', width)
            
            
        % ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
        case 2 % Controllability
            fprintf(cli_bf(' -- Controllability -- \n'))
            cli_disp('We can use the provided function for checking controllability based on the data.', width);
            
            fprintf('\n')
            cli_disp('[bool] = isInformControllable(X)', width)
            cli_disp(sprintf('bool = %d\n', isInformControllable(X_true)), width)
            
            fprintf('\n')
            cli_disp('As we can see the data is informative for controllability eventhough it is not informative for system identification. This is because all systems that can generate this data are controllable.', width)
            
            fprintf('\n')
            cli_disp(join(['Since the systems that discribes this data are all controllable we might be able to find a controller that stabilises all these system. ' ...
                           'However, this is not guaranteed since we need to find a controler that is applicable for all systems dyscribed by the data.'], ''), width)
            
            fprintf('\n')
            cli_disp(join(['To check if the data is informative for controllability we need that X₊ is full row rank and that X₊ - λ * X₋ is full row rank for all λ ≠ 0 such that λ⁻¹∈σ(X₋ * (X₊)^i) where (X₊)^i is a right inverse of X₊. ']), width)
        
            
        % ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        case 3 % Stabillisability
            fprintf(cli_bf(' -- Stabilisability -- \n'))
            cli_disp('We can use the provided function for checking stabilisability based on the data.', width);
            
            fprintf('\n')
            cli_disp('[bool] = isInformStabilisable(X)', width)
            cli_disp(sprintf('bool = %d\n', isInformStabilisable(X_true)), width)
            
            fprintf('\n')
            cli_disp(join(['As we can see the data is informative for stabilisability. This is as expected since the data is also informative for controllability, hence we know that all system that can generate the data are controllable and hence stabilisable.']), width)
            
            fprintf('\n')
            cli_disp(join(['To check if the data to be informative for stabilisability we need that X₊ - X₋ is full row rank and that X₊ - λ * X₋ is full row rank for all λ ≠ 1 such that (λ-1)⁻¹∈σ(X₋ (X₊ - X₋)^i) where (X₊ - X₋)^i is a right inverse of X₊ - X₋. ']), width)

            
        % ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------               
        case 4 % State feedback
            fprintf(cli_bf(' -- Stabilisation by state feedback -- \n'))
            cli_disp(join(['We want to find a full state feedback controller that stabilises all systems describing the data at the same time. '...
                           'Since the data is not informative for system identification we know that there are an infinite amount of systems that are able to generate the data. '...
                           'However, we also know that all of these systems are stabilisable and even controllable. '... 
                           'To check if the data is informative for state feedback we can use the provided function.']),width)
                       
            fprintf('\n')           
            cli_disp('[bool, K] = isInformStateFeedback(X, U)',width)
            [b_sf, K_sf] = isInformStateFeedback(X_true, U_true);
            cli_disp(sprintf('bool = %d\n', b_sf), width)
            
            fprintf('\n') 
            cli_disp(join(['As we can see the data is informative for stabilisation by state feedback using the controller:']),width)
            disp(K_sf)
            cli_disp('Which will result in a closed loop system with eigenvalues at:',width)
            disp(eig(A_true + B_true * K_sf)')
            
            cli_disp('Although a state feedback controller exist, it is not directly implied by informativivity of controlability or stabilisability. This is because even if all systems can be stabilised on their own, it does not automaticaly imply that there exists a single controller that stabilises all of them.', width)
            
            fprintf('\n')
            cli_disp(join(['For the data to be informative for stabilisation by state feedback if X₋ has full row rank and there exists a right inverse (X₋)^i  of X₋ such that X₊ * (X₋)^i is stable. ' ...
                           'If we have such a right inverse that the controller is given by K = U * (X₋)^i. ']), width)
            
            
        % ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
        case 5 % Deadbeat control
            fprintf(cli_bf(' -- Stabilisation by deadbeat control -- \n'))
            cli_disp(join(['We have seen that there exist a stabilising controller such that all systems that are able to generate the data are stabilised. '...
                           'However, lets say that we want to have a specific controller that stabilises the system in 1 iteration, i.e. a deadbeat controller. '...
                           'Then we can check if the data is informative for deadbeat control by using the provided function.']),width)
            
            fprintf('\n') 
            cli_disp('[bool, K] = isInformStateFeedback(X, U)',width)
            [b_db, K_db] = isInformDeadbeatControl(X_true, U_true);
            cli_disp(sprintf('bool = %d\n', b_db), width)
            
            fprintf('\n')
            cli_disp(join(['As we can see the data is informative for deadbeat control using the controller:']),width)
            disp(K_db)
            cli_disp('Which will result in a closed loop system with eigenvalues at:',width)
            disp(eig(A_true + B_true * K_db)')
            
            cli_disp('As we can see the closed loop system has poles that are tending to zero. However, due to limitation in the poleplacement algorithms provided by Matlab, the eigenvalues are still reletively big.')
            
            fprintf('\n')
            cli_disp(join(['For the data to be informative for deadbeat control, X₋ needs to have full rank and there needs to exists a right inverse (X₋)^i  of X₋ such that X₊ * (X₋)^i is nilpotent. ' ...
                           'To do this we will find F and G such that X₋ * [F G] = [I 0]. ' ...
                           'Since we can express the right inverse as (X₋)^i = F + GH for an arbitrary H, we are able to reduce the problem to a pole placement problem.']), width)
            
                       
        % ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
        case 6 % LQR
            fprintf(cli_bf(' -- Linear quadratic regulation -- \n'))
            cli_disp(join(['Before we check if the data is informative for LQR control, we first need to define our cost matrices. We will pick Q to be the zero matrix and R to be the identitity matrix of size 2. Now we can check if the data is informative for LQR control by using the provided function.']),width)
            
            fprintf('\n') 
            cli_disp('[bool] = isInformLQR(X, U, Q, R)',width)
            [b_lqr] = isInformLQR(X_true, U_true, zeros(3,3), eye(2));
            cli_disp(sprintf('bool = %d\n', b_lqr), width)
            
            fprintf('\n')
            cli_disp('As we can see the data is not informative for LQR control.', width)
            
            fprintf('\n')
            cli_disp('This is because the data is only informative for LQR control if the data is informative for system identification or if all systems being able to generate the data have the same A matrix , that A matrix is stable and QA = 0. However, in our case the data is not informative for system identification and A is not stable. Hence the data is not informative for LQR control.',width)
        
        % ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
        case 7 % Dynamic measurement feedback
            fprintf(cli_bf(' -- Stabilisation by dynamic measurment feedback -- \n'))
            cli_disp(join(['Before we look at how to compute a dynamic measurement controller from the data, we need to define a output function. We will pick the following C and D matrix. ']),width)
            
            C = [1 0 0 ; 0 1 0]
            D = [0 0 ; 0 1]
            
            cli_disp('Using these we can generate an output sequence Y.',width)
            cli_press_any_key()
            
            U = U_true
            X = X_true
            Y = C * X_true(:,1:end-1) + D * U_true
            
            fprintf('\n') 
            cli_disp('[bool, K] = isInformDynamicMeasurementFeedback(X, U, Y)',width)
            [b_dmfb] = isInformDynamicMeasurementFeedback(X_true, U_true, Y);
            cli_disp(sprintf('bool = %d\n', b_dmfb), width)
            
            fprintf('\n')
            cli_disp('As we can see the data is not informative for dynamic measurement feedback.', width)
            
            fprintf('\n')
            cli_disp('This is because the data is only informative for dynamic measurement feedback if the daat is informative for system identification. Since our data is not informative for system identification it is also not informative for stabilisation by dynamic measurement feedback.',width)
        
          
        % ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
        case 8 % Show data again   
            X
            U
    end
    fprintf('\n');
    response = cli_options(options, width);
end







